review:
	1.模板
	2.类模板
		2.1 类型参数
		2.2 普通参数(非类型参数)
		2.3 使用默认值
	3.函数模板
		3.1 类型参数,普通参数
		3.2 不能有默认值
		3.3 类型推断
			根据调用函数时的参数类型自动推断出模板参数类型。
			注意:类型推断可能失效,此时只能传入模板参数
	4.特化和偏特化
		对于特定类型,模板的代码不能满足实际需要时,就得重写此模板,重写的模板就是特化模板,如果类型是某一类(多种,一般为所有的指针),重写的模板就是偏特化的。

now:
 STL : Standard Template Library 
	标准模板库
		包含了典型的数据结构和算法的实现。
 Boost : 准标准模板库
	
 STL的一个很重要的设计原则是效率优先。
	
1.迭代器
	1.1 迭代器是一个对象,这个对象非常类似于指针,它重载了指针的所有运算符(几乎所有):
		* -> ++ -- + - 
	所以,完全可以将此对象当指针来用,当指针来看。
	*it; it-> it++; it--; it+4; it-3;	
	1.2 迭代器这个指针指向的是容器中的元素。
	1.3 迭代器类名叫iterator,但此类是容器类的一个内部类。
	1.4 获取迭代器对象
		迭代器对象只能由容器返回,程序员自己无法构造迭代器对象,只能向容器申请一个。
		所有的容器都有以下函数返回迭代器对象:
			.begin();//返回的迭代器指向了容器中的第一元素。
			.end();//返回的迭代器指向了最后一个元素的下一个位置。
	1.5 反向迭代器
		.rbegin();//返回一个反向迭代器,在此返回的迭代器指向了容器中最后一个元素。
		.rend();//返回的是容器中第一个元素前面的那个位置。
		反向迭代器的类型为:reverse_iterator,也是内部类
		反向迭代器的++运行其实向前走。

2.vector
	2.1 底层是数组实现的。
	2.2 扩容也是翻倍的 0->1->2->4->8....
	2.3 注意事项:
		1)当向vector中放入大量的数据时,尽量使用reserve约定好需要的容量,以防止频繁扩容造成的效率降低。	
		2)vector是由数组的实现,检索效率高,但是,在vector的非末尾位置进行插入和删除的效率低。
		所以使用vector时尽量不要频繁地在非末尾位置进行增删。
		3)在vector的最后一个位置增加数据,或删除最后一个位置的数据的效率是很高,所以建议尽量多使用:
	push_back, pop_back 这两个函数。

3. deque  double ended queue 双端队列



自己写vector list 
	难点在迭代器


















		







	
	

















